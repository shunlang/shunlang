"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shun.shun->kl (V13104 V13105) (compile (lambda X (shun.<define> X)) (cons V13104 V13105) (lambda X (shun.shun-syntax-error V13104 X))))

(defun shun.shun-syntax-error (V13112 V13113) (cond ((cons? V13113) (simple-error (cn "syntax error in " (shun.app V13112 (cn " here:

 " (shun.app (shun.next-50 50 (hd V13113)) "
" shun.a)) shun.a)))) (true (simple-error (cn "syntax error in " (shun.app V13112 "
" shun.a))))))

(defun shun.<define> (V13115) (let YaccParse (let Parse_shun.<name> (shun.<name> V13115) (if (not (= (fail) Parse_shun.<name>)) (let Parse_shun.<signature> (shun.<signature> Parse_shun.<name>) (if (not (= (fail) Parse_shun.<signature>)) (let Parse_shun.<rules> (shun.<rules> Parse_shun.<signature>) (if (not (= (fail) Parse_shun.<rules>)) (shun.pair (hd Parse_shun.<rules>) (shun.compile_to_machine_code (shun.hdtl Parse_shun.<name>) (shun.hdtl Parse_shun.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shun.<name> (shun.<name> V13115) (if (not (= (fail) Parse_shun.<name>)) (let Parse_shun.<rules> (shun.<rules> Parse_shun.<name>) (if (not (= (fail) Parse_shun.<rules>)) (shun.pair (hd Parse_shun.<rules>) (shun.compile_to_machine_code (shun.hdtl Parse_shun.<name>) (shun.hdtl Parse_shun.<rules>))) (fail))) (fail))) YaccParse)))

(defun shun.<name> (V13117) (if (cons? (hd V13117)) (let Parse_X (hd (hd V13117)) (shun.pair (hd (shun.pair (tl (hd V13117)) (shun.hdtl V13117))) (if (and (symbol? Parse_X) (not (shun.sysfunc? Parse_X))) Parse_X (simple-error (shun.app Parse_X " is not a legitimate function name.
" shun.a))))) (fail)))

(defun shun.sysfunc? (V13119) (element? V13119 (get (intern "shun") shun.external-symbols (value *property-vector*))))

(defun shun.<signature> (V13121) (if (and (cons? (hd V13121)) (= { (hd (hd V13121)))) (let Parse_shun.<signature-help> (shun.<signature-help> (shun.pair (tl (hd V13121)) (shun.hdtl V13121))) (if (not (= (fail) Parse_shun.<signature-help>)) (if (and (cons? (hd Parse_shun.<signature-help>)) (= } (hd (hd Parse_shun.<signature-help>)))) (shun.pair (hd (shun.pair (tl (hd Parse_shun.<signature-help>)) (shun.hdtl Parse_shun.<signature-help>))) (shun.demodulate (shun.curry-type (shun.hdtl Parse_shun.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shun.curry-type (V13123) (cond ((and (cons? V13123) (and (cons? (tl V13123)) (and (= --> (hd (tl V13123))) (and (cons? (tl (tl V13123))) (and (cons? (tl (tl (tl V13123)))) (= --> (hd (tl (tl (tl V13123)))))))))) (shun.curry-type (cons (hd V13123) (cons --> (cons (tl (tl V13123)) ()))))) ((and (cons? V13123) (and (cons? (tl V13123)) (and (= * (hd (tl V13123))) (and (cons? (tl (tl V13123))) (and (cons? (tl (tl (tl V13123)))) (= * (hd (tl (tl (tl V13123)))))))))) (shun.curry-type (cons (hd V13123) (cons * (cons (tl (tl V13123)) ()))))) ((cons? V13123) (map (lambda Z (shun.curry-type Z)) V13123)) (true V13123)))

(defun shun.<signature-help> (V13125) (let YaccParse (if (cons? (hd V13125)) (let Parse_X (hd (hd V13125)) (let Parse_shun.<signature-help> (shun.<signature-help> (shun.pair (tl (hd V13125)) (shun.hdtl V13125))) (if (not (= (fail) Parse_shun.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shun.pair (hd Parse_shun.<signature-help>) (cons Parse_X (shun.hdtl Parse_shun.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V13125) (if (not (= (fail) Parse_<e>)) (shun.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shun.<rules> (V13127) (let YaccParse (let Parse_shun.<rule> (shun.<rule> V13127) (if (not (= (fail) Parse_shun.<rule>)) (let Parse_shun.<rules> (shun.<rules> Parse_shun.<rule>) (if (not (= (fail) Parse_shun.<rules>)) (shun.pair (hd Parse_shun.<rules>) (cons (shun.linearise (shun.hdtl Parse_shun.<rule>)) (shun.hdtl Parse_shun.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shun.<rule> (shun.<rule> V13127) (if (not (= (fail) Parse_shun.<rule>)) (shun.pair (hd Parse_shun.<rule>) (cons (shun.linearise (shun.hdtl Parse_shun.<rule>)) ())) (fail))) YaccParse)))

(defun shun.<rule> (V13129) (let YaccParse (let Parse_shun.<patterns> (shun.<patterns> V13129) (if (not (= (fail) Parse_shun.<patterns>)) (if (and (cons? (hd Parse_shun.<patterns>)) (= -> (hd (hd Parse_shun.<patterns>)))) (let Parse_shun.<action> (shun.<action> (shun.pair (tl (hd Parse_shun.<patterns>)) (shun.hdtl Parse_shun.<patterns>))) (if (not (= (fail) Parse_shun.<action>)) (if (and (cons? (hd Parse_shun.<action>)) (= where (hd (hd Parse_shun.<action>)))) (let Parse_shun.<guard> (shun.<guard> (shun.pair (tl (hd Parse_shun.<action>)) (shun.hdtl Parse_shun.<action>))) (if (not (= (fail) Parse_shun.<guard>)) (shun.pair (hd Parse_shun.<guard>) (cons (shun.hdtl Parse_shun.<patterns>) (cons (cons where (cons (shun.hdtl Parse_shun.<guard>) (cons (shun.hdtl Parse_shun.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shun.<patterns> (shun.<patterns> V13129) (if (not (= (fail) Parse_shun.<patterns>)) (if (and (cons? (hd Parse_shun.<patterns>)) (= -> (hd (hd Parse_shun.<patterns>)))) (let Parse_shun.<action> (shun.<action> (shun.pair (tl (hd Parse_shun.<patterns>)) (shun.hdtl Parse_shun.<patterns>))) (if (not (= (fail) Parse_shun.<action>)) (shun.pair (hd Parse_shun.<action>) (cons (shun.hdtl Parse_shun.<patterns>) (cons (shun.hdtl Parse_shun.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shun.<patterns> (shun.<patterns> V13129) (if (not (= (fail) Parse_shun.<patterns>)) (if (and (cons? (hd Parse_shun.<patterns>)) (= <- (hd (hd Parse_shun.<patterns>)))) (let Parse_shun.<action> (shun.<action> (shun.pair (tl (hd Parse_shun.<patterns>)) (shun.hdtl Parse_shun.<patterns>))) (if (not (= (fail) Parse_shun.<action>)) (if (and (cons? (hd Parse_shun.<action>)) (= where (hd (hd Parse_shun.<action>)))) (let Parse_shun.<guard> (shun.<guard> (shun.pair (tl (hd Parse_shun.<action>)) (shun.hdtl Parse_shun.<action>))) (if (not (= (fail) Parse_shun.<guard>)) (shun.pair (hd Parse_shun.<guard>) (cons (shun.hdtl Parse_shun.<patterns>) (cons (cons where (cons (shun.hdtl Parse_shun.<guard>) (cons (cons shun.choicepoint! (cons (shun.hdtl Parse_shun.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shun.<patterns> (shun.<patterns> V13129) (if (not (= (fail) Parse_shun.<patterns>)) (if (and (cons? (hd Parse_shun.<patterns>)) (= <- (hd (hd Parse_shun.<patterns>)))) (let Parse_shun.<action> (shun.<action> (shun.pair (tl (hd Parse_shun.<patterns>)) (shun.hdtl Parse_shun.<patterns>))) (if (not (= (fail) Parse_shun.<action>)) (shun.pair (hd Parse_shun.<action>) (cons (shun.hdtl Parse_shun.<patterns>) (cons (cons shun.choicepoint! (cons (shun.hdtl Parse_shun.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shun.fail_if (V13132 V13133) (if (V13132 V13133) (fail) V13133))

(defun shun.succeeds? (V13139) (cond ((= V13139 (fail)) false) (true true)))

(defun shun.<patterns> (V13141) (let YaccParse (let Parse_shun.<pattern> (shun.<pattern> V13141) (if (not (= (fail) Parse_shun.<pattern>)) (let Parse_shun.<patterns> (shun.<patterns> Parse_shun.<pattern>) (if (not (= (fail) Parse_shun.<patterns>)) (shun.pair (hd Parse_shun.<patterns>) (cons (shun.hdtl Parse_shun.<pattern>) (shun.hdtl Parse_shun.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V13141) (if (not (= (fail) Parse_<e>)) (shun.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shun.<pattern> (V13148) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (= @p (hd (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))))) (let Parse_shun.<pattern1> (shun.<pattern1> (shun.pair (tl (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (shun.hdtl (shun.pair (hd (hd V13148)) (hd (tl V13148)))))) (if (not (= (fail) Parse_shun.<pattern1>)) (let Parse_shun.<pattern2> (shun.<pattern2> Parse_shun.<pattern1>) (if (not (= (fail) Parse_shun.<pattern2>)) (shun.pair (hd (shun.pair (tl (hd V13148)) (hd (tl V13148)))) (cons @p (cons (shun.hdtl Parse_shun.<pattern1>) (cons (shun.hdtl Parse_shun.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (= cons (hd (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))))) (let Parse_shun.<pattern1> (shun.<pattern1> (shun.pair (tl (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (shun.hdtl (shun.pair (hd (hd V13148)) (hd (tl V13148)))))) (if (not (= (fail) Parse_shun.<pattern1>)) (let Parse_shun.<pattern2> (shun.<pattern2> Parse_shun.<pattern1>) (if (not (= (fail) Parse_shun.<pattern2>)) (shun.pair (hd (shun.pair (tl (hd V13148)) (hd (tl V13148)))) (cons cons (cons (shun.hdtl Parse_shun.<pattern1>) (cons (shun.hdtl Parse_shun.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (= @v (hd (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))))) (let Parse_shun.<pattern1> (shun.<pattern1> (shun.pair (tl (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (shun.hdtl (shun.pair (hd (hd V13148)) (hd (tl V13148)))))) (if (not (= (fail) Parse_shun.<pattern1>)) (let Parse_shun.<pattern2> (shun.<pattern2> Parse_shun.<pattern1>) (if (not (= (fail) Parse_shun.<pattern2>)) (shun.pair (hd (shun.pair (tl (hd V13148)) (hd (tl V13148)))) (cons @v (cons (shun.hdtl Parse_shun.<pattern1>) (cons (shun.hdtl Parse_shun.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (= @s (hd (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))))) (let Parse_shun.<pattern1> (shun.<pattern1> (shun.pair (tl (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (shun.hdtl (shun.pair (hd (hd V13148)) (hd (tl V13148)))))) (if (not (= (fail) Parse_shun.<pattern1>)) (let Parse_shun.<pattern2> (shun.<pattern2> Parse_shun.<pattern1>) (if (not (= (fail) Parse_shun.<pattern2>)) (shun.pair (hd (shun.pair (tl (hd V13148)) (hd (tl V13148)))) (cons @s (cons (shun.hdtl Parse_shun.<pattern1>) (cons (shun.hdtl Parse_shun.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (= vector (hd (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))))) (if (and (cons? (hd (shun.pair (tl (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (shun.hdtl (shun.pair (hd (hd V13148)) (hd (tl V13148))))))) (= 0 (hd (hd (shun.pair (tl (hd (shun.pair (hd (hd V13148)) (hd (tl V13148))))) (shun.hdtl (shun.pair (hd (hd V13148)) (hd (tl V13148))))))))) (shun.pair (hd (shun.pair (tl (hd V13148)) (hd (tl V13148)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V13148)) (let Parse_X (hd (hd V13148)) (if (cons? Parse_X) (shun.pair (hd (shun.pair (tl (hd V13148)) (shun.hdtl V13148))) (shun.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shun.<simple_pattern> (shun.<simple_pattern> V13148) (if (not (= (fail) Parse_shun.<simple_pattern>)) (shun.pair (hd Parse_shun.<simple_pattern>) (shun.hdtl Parse_shun.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shun.constructor-error (V13150) (simple-error (shun.app V13150 " is not a legitimate constructor
" shun.a)))

(defun shun.<simple_pattern> (V13152) (let YaccParse (if (cons? (hd V13152)) (let Parse_X (hd (hd V13152)) (if (= Parse_X _) (shun.pair (hd (shun.pair (tl (hd V13152)) (shun.hdtl V13152))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V13152)) (let Parse_X (hd (hd V13152)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shun.pair (hd (shun.pair (tl (hd V13152)) (shun.hdtl V13152))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shun.<pattern1> (V13154) (let Parse_shun.<pattern> (shun.<pattern> V13154) (if (not (= (fail) Parse_shun.<pattern>)) (shun.pair (hd Parse_shun.<pattern>) (shun.hdtl Parse_shun.<pattern>)) (fail))))

(defun shun.<pattern2> (V13156) (let Parse_shun.<pattern> (shun.<pattern> V13156) (if (not (= (fail) Parse_shun.<pattern>)) (shun.pair (hd Parse_shun.<pattern>) (shun.hdtl Parse_shun.<pattern>)) (fail))))

(defun shun.<action> (V13158) (if (cons? (hd V13158)) (let Parse_X (hd (hd V13158)) (shun.pair (hd (shun.pair (tl (hd V13158)) (shun.hdtl V13158))) Parse_X)) (fail)))

(defun shun.<guard> (V13160) (if (cons? (hd V13160)) (let Parse_X (hd (hd V13160)) (shun.pair (hd (shun.pair (tl (hd V13160)) (shun.hdtl V13160))) Parse_X)) (fail)))

(defun shun.compile_to_machine_code (V13163 V13164) (let Lambda+ (shun.compile_to_lambda+ V13163 V13164) (let KL (shun.compile_to_kl V13163 Lambda+) (let Record (shun.record-source V13163 KL) KL))))

(defun shun.record-source (V13169 V13170) (cond ((value shun.*installing-kl*) shun.skip) (true (put V13169 shun.source V13170 (value *property-vector*)))))

(defun shun.compile_to_lambda+ (V13173 V13174) (let Arity (shun.aritycheck V13173 V13174) (let UpDateSymbolTable (shun.update-symbol-table V13173 Arity) (let Free (map (lambda Rule (shun.free_variable_check V13173 Rule)) V13174) (let Variables (shun.parameters Arity) (let Strip (map (lambda X (shun.strip-protect X)) V13174) (let Abstractions (map (lambda X (shun.abstract_rule X)) Strip) (let Applications (map (lambda X (shun.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shun.update-symbol-table (V13177 V13178) (set shun.*symbol-table* (shun.update-symbol-table-h V13177 V13178 (value shun.*symbol-table*) ())))

(defun shun.update-symbol-table-h (V13186 V13187 V13188 V13189) (cond ((= () V13188) (let NewEntry (cons V13186 (eval-kl (shun.lambda-form V13186 V13187))) (cons NewEntry V13189))) ((and (cons? V13188) (and (cons? (hd V13188)) (= (hd (hd V13188)) V13186))) (let ChangedEntry (cons (hd (hd V13188)) (eval-kl (shun.lambda-form (hd (hd V13188)) V13187))) (append (tl V13188) (cons ChangedEntry V13189)))) ((cons? V13188) (shun.update-symbol-table-h V13186 V13187 (tl V13188) (cons (hd V13188) V13189))) (true (shun.f_error shun.update-symbol-table-h))))

(defun shun.free_variable_check (V13192 V13193) (cond ((and (cons? V13193) (and (cons? (tl V13193)) (= () (tl (tl V13193))))) (let Bound (shun.extract_vars (hd V13193)) (let Free (shun.extract_free_vars Bound (hd (tl V13193))) (shun.free_variable_warnings V13192 Free)))) (true (shun.f_error shun.free_variable_check))))

(defun shun.extract_vars (V13195) (cond ((variable? V13195) (cons V13195 ())) ((cons? V13195) (union (shun.extract_vars (hd V13195)) (shun.extract_vars (tl V13195)))) (true ())))

(defun shun.extract_free_vars (V13207 V13208) (cond ((and (cons? V13208) (and (cons? (tl V13208)) (and (= () (tl (tl V13208))) (= (hd V13208) protect)))) ()) ((and (variable? V13208) (not (element? V13208 V13207))) (cons V13208 ())) ((and (cons? V13208) (and (= lambda (hd V13208)) (and (cons? (tl V13208)) (and (cons? (tl (tl V13208))) (= () (tl (tl (tl V13208)))))))) (shun.extract_free_vars (cons (hd (tl V13208)) V13207) (hd (tl (tl V13208))))) ((and (cons? V13208) (and (= let (hd V13208)) (and (cons? (tl V13208)) (and (cons? (tl (tl V13208))) (and (cons? (tl (tl (tl V13208)))) (= () (tl (tl (tl (tl V13208)))))))))) (union (shun.extract_free_vars V13207 (hd (tl (tl V13208)))) (shun.extract_free_vars (cons (hd (tl V13208)) V13207) (hd (tl (tl (tl V13208))))))) ((cons? V13208) (union (shun.extract_free_vars V13207 (hd V13208)) (shun.extract_free_vars V13207 (tl V13208)))) (true ())))

(defun shun.free_variable_warnings (V13213 V13214) (cond ((= () V13214) _) (true (simple-error (cn "error: the following variables are free in " (shun.app V13213 (cn ": " (shun.app (shun.list_variables V13214) "" shun.a)) shun.a))))))

(defun shun.list_variables (V13216) (cond ((and (cons? V13216) (= () (tl V13216))) (cn (str (hd V13216)) ".")) ((cons? V13216) (cn (str (hd V13216)) (cn ", " (shun.list_variables (tl V13216))))) (true (shun.f_error shun.list_variables))))

(defun shun.strip-protect (V13218) (cond ((and (cons? V13218) (and (cons? (tl V13218)) (and (= () (tl (tl V13218))) (= (hd V13218) protect)))) (shun.strip-protect (hd (tl V13218)))) ((cons? V13218) (map (lambda Z (shun.strip-protect Z)) V13218)) (true V13218)))

(defun shun.linearise (V13220) (cond ((and (cons? V13220) (and (cons? (tl V13220)) (= () (tl (tl V13220))))) (shun.linearise_help (shun.flatten (hd V13220)) (hd V13220) (hd (tl V13220)))) (true (shun.f_error shun.linearise))))

(defun shun.flatten (V13222) (cond ((= () V13222) ()) ((cons? V13222) (append (shun.flatten (hd V13222)) (shun.flatten (tl V13222)))) (true (cons V13222 ()))))

(defun shun.linearise_help (V13226 V13227 V13228) (cond ((= () V13226) (cons V13227 (cons V13228 ()))) ((cons? V13226) (if (and (variable? (hd V13226)) (element? (hd V13226) (tl V13226))) (let Var (gensym (hd V13226)) (let NewAction (cons where (cons (cons = (cons (hd V13226) (cons Var ()))) (cons V13228 ()))) (let NewPatts (shun.linearise_X (hd V13226) Var V13227) (shun.linearise_help (tl V13226) NewPatts NewAction)))) (shun.linearise_help (tl V13226) V13227 V13228))) (true (shun.f_error shun.linearise_help))))

(defun shun.linearise_X (V13241 V13242 V13243) (cond ((= V13243 V13241) V13242) ((cons? V13243) (let L (shun.linearise_X V13241 V13242 (hd V13243)) (if (= L (hd V13243)) (cons (hd V13243) (shun.linearise_X V13241 V13242 (tl V13243))) (cons L (tl V13243))))) (true V13243)))

(defun shun.aritycheck (V13246 V13247) (cond ((and (cons? V13247) (and (cons? (hd V13247)) (and (cons? (tl (hd V13247))) (and (= () (tl (tl (hd V13247)))) (= () (tl V13247)))))) (do (shun.aritycheck-action (hd (tl (hd V13247)))) (shun.aritycheck-name V13246 (arity V13246) (length (hd (hd V13247)))))) ((and (cons? V13247) (and (cons? (hd V13247)) (and (cons? (tl (hd V13247))) (and (= () (tl (tl (hd V13247)))) (and (cons? (tl V13247)) (and (cons? (hd (tl V13247))) (and (cons? (tl (hd (tl V13247)))) (= () (tl (tl (hd (tl V13247)))))))))))) (if (= (length (hd (hd V13247))) (length (hd (hd (tl V13247))))) (do (shun.aritycheck-action (hd (tl (hd V13247)))) (shun.aritycheck V13246 (tl V13247))) (simple-error (cn "arity error in " (shun.app V13246 "
" shun.a))))) (true (shun.f_error shun.aritycheck))))

(defun shun.aritycheck-name (V13260 V13261 V13262) (cond ((= -1 V13261) V13262) ((= V13262 V13261) V13262) (true (do (shun.prhush (cn "
warning: changing the arity of " (shun.app V13260 " can cause errors.
" shun.a)) (stoutput)) V13262))))

(defun shun.aritycheck-action (V13268) (cond ((cons? V13268) (do (shun.aah (hd V13268) (tl V13268)) (map (lambda Y (shun.aritycheck-action Y)) V13268))) (true shun.skip)))

(defun shun.aah (V13271 V13272) (let Arity (arity V13271) (let Len (length V13272) (if (and (> Arity -1) (> Len Arity)) (shun.prhush (cn "warning: " (shun.app V13271 (cn " might not like " (shun.app Len (cn " argument" (shun.app (if (> Len 1) "s" "") ".
" shun.a)) shun.a)) shun.a)) (stoutput)) shun.skip))))

(defun shun.abstract_rule (V13274) (cond ((and (cons? V13274) (and (cons? (tl V13274)) (= () (tl (tl V13274))))) (shun.abstraction_build (hd V13274) (hd (tl V13274)))) (true (shun.f_error shun.abstract_rule))))

(defun shun.abstraction_build (V13277 V13278) (cond ((= () V13277) V13278) ((cons? V13277) (cons /. (cons (hd V13277) (cons (shun.abstraction_build (tl V13277) V13278) ())))) (true (shun.f_error shun.abstraction_build))))

(defun shun.parameters (V13280) (cond ((= 0 V13280) ()) (true (cons (gensym V) (shun.parameters (- V13280 1))))))

(defun shun.application_build (V13283 V13284) (cond ((= () V13283) V13284) ((cons? V13283) (shun.application_build (tl V13283) (cons V13284 (cons (hd V13283) ())))) (true (shun.f_error shun.application_build))))

(defun shun.compile_to_kl (V13287 V13288) (cond ((and (cons? V13288) (and (cons? (tl V13288)) (= () (tl (tl V13288))))) (let Arity (shun.store-arity V13287 (length (hd V13288))) (let Reduce (map (lambda X (shun.reduce X)) (hd (tl V13288))) (let CondExpression (shun.cond-expression V13287 (hd V13288) Reduce) (let TypeTable (if (value shun.*optimise*) (shun.typextable (shun.get-type V13287) (hd V13288)) shun.skip) (let TypedCondExpression (if (value shun.*optimise*) (shun.assign-types (hd V13288) TypeTable CondExpression) CondExpression) (let KL (cons defun (cons V13287 (cons (hd V13288) (cons TypedCondExpression ())))) KL))))))) (true (shun.f_error shun.compile_to_kl))))

(defun shun.get-type (V13294) (cond ((cons? V13294) shun.skip) (true (let FType (assoc V13294 (value shun.*signedfuncs*)) (if (empty? FType) shun.skip (tl FType))))))

(defun shun.typextable (V13305 V13306) (cond ((and (cons? V13305) (and (cons? (tl V13305)) (and (= --> (hd (tl V13305))) (and (cons? (tl (tl V13305))) (and (= () (tl (tl (tl V13305)))) (cons? V13306)))))) (if (variable? (hd V13305)) (shun.typextable (hd (tl (tl V13305))) (tl V13306)) (cons (cons (hd V13306) (hd V13305)) (shun.typextable (hd (tl (tl V13305))) (tl V13306))))) (true ())))

(defun shun.assign-types (V13310 V13311 V13312) (cond ((and (cons? V13312) (and (= let (hd V13312)) (and (cons? (tl V13312)) (and (cons? (tl (tl V13312))) (and (cons? (tl (tl (tl V13312)))) (= () (tl (tl (tl (tl V13312)))))))))) (cons let (cons (hd (tl V13312)) (cons (shun.assign-types V13310 V13311 (hd (tl (tl V13312)))) (cons (shun.assign-types (cons (hd (tl V13312)) V13310) V13311 (hd (tl (tl (tl V13312))))) ()))))) ((and (cons? V13312) (and (= lambda (hd V13312)) (and (cons? (tl V13312)) (and (cons? (tl (tl V13312))) (= () (tl (tl (tl V13312)))))))) (cons lambda (cons (hd (tl V13312)) (cons (shun.assign-types (cons (hd (tl V13312)) V13310) V13311 (hd (tl (tl V13312)))) ())))) ((and (cons? V13312) (= cond (hd V13312))) (cons cond (map (lambda Y (cons (shun.assign-types V13310 V13311 (hd Y)) (cons (shun.assign-types V13310 V13311 (hd (tl Y))) ()))) (tl V13312)))) ((cons? V13312) (let NewTable (shun.typextable (shun.get-type (hd V13312)) (tl V13312)) (cons (hd V13312) (map (lambda Y (shun.assign-types V13310 (append V13311 NewTable) Y)) (tl V13312))))) (true (let AtomType (assoc V13312 V13311) (if (cons? AtomType) (cons type (cons V13312 (cons (tl AtomType) ()))) (if (element? V13312 V13310) V13312 (shun.atom-type V13312)))))))

(defun shun.atom-type (V13314) (if (string? V13314) (cons type (cons V13314 (cons string ()))) (if (number? V13314) (cons type (cons V13314 (cons number ()))) (if (boolean? V13314) (cons type (cons V13314 (cons boolean ()))) (if (symbol? V13314) (cons type (cons V13314 (cons symbol ()))) V13314)))))

(defun shun.store-arity (V13319 V13320) (cond ((value shun.*installing-kl*) shun.skip) (true (put V13319 arity V13320 (value *property-vector*)))))

(defun shun.reduce (V13322) (do (set shun.*teststack* ()) (let Result (shun.reduce_help V13322) (cons (cons : (cons shun.tests (reverse (value shun.*teststack*)))) (cons Result ())))))

(defun shun.reduce_help (V13324) (cond ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (hd (tl (hd V13324)))) (and (= cons (hd (hd (tl (hd V13324))))) (and (cons? (tl (hd (tl (hd V13324))))) (and (cons? (tl (tl (hd (tl (hd V13324)))))) (and (= () (tl (tl (tl (hd (tl (hd V13324))))))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324))))))))))))))) (do (shun.add_test (cons cons? (tl V13324))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V13324))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V13324)))))) (cons (shun.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V13324)) ())) (cons (cons tl (tl V13324)) ())) (shun.reduce_help Application))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (hd (tl (hd V13324)))) (and (= @p (hd (hd (tl (hd V13324))))) (and (cons? (tl (hd (tl (hd V13324))))) (and (cons? (tl (tl (hd (tl (hd V13324)))))) (and (= () (tl (tl (tl (hd (tl (hd V13324))))))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324))))))))))))))) (do (shun.add_test (cons tuple? (tl V13324))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V13324))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V13324)))))) (cons (shun.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V13324)) ())) (cons (cons snd (tl V13324)) ())) (shun.reduce_help Application))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (hd (tl (hd V13324)))) (and (= @v (hd (hd (tl (hd V13324))))) (and (cons? (tl (hd (tl (hd V13324))))) (and (cons? (tl (tl (hd (tl (hd V13324)))))) (and (= () (tl (tl (tl (hd (tl (hd V13324))))))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324))))))))))))))) (do (shun.add_test (cons shun.+vector? (tl V13324))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V13324))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V13324)))))) (cons (shun.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V13324)) ())) (cons (cons tlv (tl V13324)) ())) (shun.reduce_help Application))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (hd (tl (hd V13324)))) (and (= @s (hd (hd (tl (hd V13324))))) (and (cons? (tl (hd (tl (hd V13324))))) (and (cons? (tl (tl (hd (tl (hd V13324)))))) (and (= () (tl (tl (tl (hd (tl (hd V13324))))))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324))))))))))))))) (do (shun.add_test (cons shun.+string? (tl V13324))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V13324))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V13324)))))) (cons (shun.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V13324)) (cons 0 ()))) ())) (cons (cons tlstr (tl V13324)) ())) (shun.reduce_help Application))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (and (= () (tl (tl V13324))) (not (variable? (hd (tl (hd V13324))))))))))))) (do (shun.add_test (cons = (cons (hd (tl (hd V13324))) (tl V13324)))) (shun.reduce_help (hd (tl (tl (hd V13324))))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324)))))))))) (shun.reduce_help (shun.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))))) ((and (cons? V13324) (and (= where (hd V13324)) (and (cons? (tl V13324)) (and (cons? (tl (tl V13324))) (= () (tl (tl (tl V13324)))))))) (do (shun.add_test (hd (tl V13324))) (shun.reduce_help (hd (tl (tl V13324)))))) ((and (cons? V13324) (and (cons? (tl V13324)) (= () (tl (tl V13324))))) (let Z (shun.reduce_help (hd V13324)) (if (= (hd V13324) Z) V13324 (shun.reduce_help (cons Z (tl V13324)))))) (true V13324)))

(defun shun.+string? (V13326) (cond ((= "" V13326) false) (true (string? V13326))))

(defun shun.+vector (V13328) (cond ((= V13328 (vector 0)) false) (true (vector? V13328))))

(defun shun.ebr (V13342 V13343 V13344) (cond ((= V13344 V13343) V13342) ((and (cons? V13344) (and (= /. (hd V13344)) (and (cons? (tl V13344)) (and (cons? (tl (tl V13344))) (and (= () (tl (tl (tl V13344)))) (> (occurrences V13343 (hd (tl V13344))) 0)))))) V13344) ((and (cons? V13344) (and (= lambda (hd V13344)) (and (cons? (tl V13344)) (and (cons? (tl (tl V13344))) (and (= () (tl (tl (tl V13344)))) (> (occurrences V13343 (hd (tl V13344))) 0)))))) V13344) ((and (cons? V13344) (and (= let (hd V13344)) (and (cons? (tl V13344)) (and (cons? (tl (tl V13344))) (and (cons? (tl (tl (tl V13344)))) (and (= () (tl (tl (tl (tl V13344))))) (= (hd (tl V13344)) V13343))))))) (cons let (cons (hd (tl V13344)) (cons (shun.ebr V13342 (hd (tl V13344)) (hd (tl (tl V13344)))) (tl (tl (tl V13344))))))) ((cons? V13344) (cons (shun.ebr V13342 V13343 (hd V13344)) (shun.ebr V13342 V13343 (tl V13344)))) (true V13344)))

(defun shun.add_test (V13346) (set shun.*teststack* (cons V13346 (value shun.*teststack*))))

(defun shun.cond-expression (V13350 V13351 V13352) (let Err (shun.err-condition V13350) (let Cases (shun.case-form V13352 Err) (let EncodeChoices (shun.encode-choices Cases V13350) (shun.cond-form EncodeChoices)))))

(defun shun.cond-form (V13356) (cond ((and (cons? V13356) (and (cons? (hd V13356)) (and (= true (hd (hd V13356))) (and (cons? (tl (hd V13356))) (= () (tl (tl (hd V13356)))))))) (hd (tl (hd V13356)))) (true (cons cond V13356))))

(defun shun.encode-choices (V13361 V13362) (cond ((= () V13361) ()) ((and (cons? V13361) (and (cons? (hd V13361)) (and (= true (hd (hd V13361))) (and (cons? (tl (hd V13361))) (and (cons? (hd (tl (hd V13361)))) (and (= shun.choicepoint! (hd (hd (tl (hd V13361))))) (and (cons? (tl (hd (tl (hd V13361))))) (and (= () (tl (tl (hd (tl (hd V13361)))))) (and (= () (tl (tl (hd V13361)))) (= () (tl V13361))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V13361))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shun.*installing-kl*) (cons shun.sys-error (cons V13362 ())) (cons shun.f_error (cons V13362 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V13361) (and (cons? (hd V13361)) (and (= true (hd (hd V13361))) (and (cons? (tl (hd V13361))) (and (cons? (hd (tl (hd V13361)))) (and (= shun.choicepoint! (hd (hd (tl (hd V13361))))) (and (cons? (tl (hd (tl (hd V13361))))) (and (= () (tl (tl (hd (tl (hd V13361)))))) (= () (tl (tl (hd V13361)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V13361))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shun.cond-form (shun.encode-choices (tl V13361) V13362)) (cons Result ())))) ())))) ())) ())) ((and (cons? V13361) (and (cons? (hd V13361)) (and (cons? (tl (hd V13361))) (and (cons? (hd (tl (hd V13361)))) (and (= shun.choicepoint! (hd (hd (tl (hd V13361))))) (and (cons? (tl (hd (tl (hd V13361))))) (and (= () (tl (tl (hd (tl (hd V13361)))))) (= () (tl (tl (hd V13361))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shun.cond-form (shun.encode-choices (tl V13361) V13362)) ())) (cons (cons if (cons (hd (hd V13361)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V13361))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V13361) (and (cons? (hd V13361)) (and (cons? (tl (hd V13361))) (= () (tl (tl (hd V13361))))))) (cons (hd V13361) (shun.encode-choices (tl V13361) V13362))) (true (shun.f_error shun.encode-choices))))

(defun shun.case-form (V13369 V13370) (cond ((= () V13369) (cons V13370 ())) ((and (cons? V13369) (and (cons? (hd V13369)) (and (cons? (hd (hd V13369))) (and (= : (hd (hd (hd V13369)))) (and (cons? (tl (hd (hd V13369)))) (and (= shun.tests (hd (tl (hd (hd V13369))))) (and (= () (tl (tl (hd (hd V13369))))) (and (cons? (tl (hd V13369))) (and (cons? (hd (tl (hd V13369)))) (and (= shun.choicepoint! (hd (hd (tl (hd V13369))))) (and (cons? (tl (hd (tl (hd V13369))))) (and (= () (tl (tl (hd (tl (hd V13369)))))) (= () (tl (tl (hd V13369)))))))))))))))) (cons (cons true (tl (hd V13369))) (shun.case-form (tl V13369) V13370))) ((and (cons? V13369) (and (cons? (hd V13369)) (and (cons? (hd (hd V13369))) (and (= : (hd (hd (hd V13369)))) (and (cons? (tl (hd (hd V13369)))) (and (= shun.tests (hd (tl (hd (hd V13369))))) (and (= () (tl (tl (hd (hd V13369))))) (and (cons? (tl (hd V13369))) (= () (tl (tl (hd V13369)))))))))))) (cons (cons true (tl (hd V13369))) ())) ((and (cons? V13369) (and (cons? (hd V13369)) (and (cons? (hd (hd V13369))) (and (= : (hd (hd (hd V13369)))) (and (cons? (tl (hd (hd V13369)))) (and (= shun.tests (hd (tl (hd (hd V13369))))) (and (cons? (tl (hd V13369))) (= () (tl (tl (hd V13369))))))))))) (cons (cons (shun.embed-and (tl (tl (hd (hd V13369))))) (tl (hd V13369))) (shun.case-form (tl V13369) V13370))) (true (shun.f_error shun.case-form))))

(defun shun.embed-and (V13372) (cond ((and (cons? V13372) (= () (tl V13372))) (hd V13372)) ((cons? V13372) (cons and (cons (hd V13372) (cons (shun.embed-and (tl V13372)) ())))) (true (shun.f_error shun.embed-and))))

(defun shun.err-condition (V13374) (cons true (cons (cons shun.f_error (cons V13374 ())) ())))

(defun shun.sys-error (V13376) (simple-error (cn "system function " (shun.app V13376 ": unexpected argument
" shun.a))))



